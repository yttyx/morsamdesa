/*
    Copyright (C) 2018  yttyx

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
*/

// audio_morse.cpp

#include <assert.h>

#include <stdio.h>
#include <stdlib.h>

#include "audio_morse.h"
#include "config.h"
#include "log.h"

using namespace  morsamdesa;

namespace morsamdesa
{

extern C_config  cfg;
extern C_log     log;


C_audio_morse::C_audio_morse( C_text_to_morse & text_to_morse )
    : C_morse( text_to_morse )
{
    sending_       = false;
    interrupt_     = false;
    element_curr_  = meNone;

    dit_           = NULL;
    dah_           = NULL;
    interelement_  = NULL;
    interletter_   = NULL;
    interword_     = NULL;

    dummy_         = NULL;
    sample_source_ = dummy_;
}

C_audio_morse::~C_audio_morse()
{
    log_writeln( C_log::LL_VERBOSE_3, "C_audio_morse destructor" );

    if ( dit_ )
    {
        delete dit_;
    }
    if ( dah_ )
    {
        delete dah_;
    }
    if ( interelement_ )
    {
        delete interelement_;
    }
    if ( interletter_ )
    {
        delete interletter_;
    }
    if ( interword_ )
    {
        delete interword_;
    }
}

/* /brief Add some sound samples to an output buffer
 *
 * /detail Supply of samples is based around supplying bursts of tick_samples samples or fewer
 *
 */
void
C_audio_morse::write()
{
    if ( sending_ )
    {
        if ( sample_source_ == dummy_ )
        {
            // Locate the first element that will cause a 'Morse on' event. Since a message can be
            // started at any position in the element stream following a mute/unmute and a resultant
            // switch from LED to audio, this prevents the audio stream from starting with a silent
            // element, which when sounder output is configured gives a spurious armature-up sound.
            
            do
            {
                element_curr_ = text_to_morse_.get_element();

            }  while ( ( element_curr_ != meEndOfMessage ) &&
                       ( element_curr_ != meDit          ) &&
                       ( element_curr_ != meDah          ) );

            select_element_sound();
        }

        // Move through the elements generated by the text to Morse conversion,
        // changing the sample source with each change of element, while providing
        // the caller with tick_samples' worth of data on each call.

        bool samples_exhausted = false;

        while ( ( ! interrupt_ ) && ( element_curr_ != meEndOfMessage ) )
        {
            if ( interrupt_ )
            {
                reset();
                break;
            }

            // write() will return either when the output buffer is full, or when the supply of input samples has been used up

            sample_source_->write( samples_exhausted );

            if ( samples_exhausted )
            {
                // Output buffer is not yet full, but this element's samples have all been used up
                
                element_curr_ = text_to_morse_.get_element();

                if ( element_curr_ == meEndOfMessage )
                {
                    reset();
                    break;
                }

                select_element_sound();
            }
            else
            {
                // Ouput buffer full, we're done
                break;
            }
        }

        if ( interrupt_ || ( element_curr_ == meEndOfMessage ) )
        {
            reset();
        }
    }
}

void
C_audio_morse::reset()
{
    dit_->reset();
    dah_->reset();
    interelement_->reset();
    interletter_->reset();
    interword_->reset();

    interrupt_     = false;
    sending_       = false;
    sample_source_ = dummy_;
}

void
C_audio_morse::select_element_sound()
{
    //log_writeln_fmt( C_log::LL_VERBOSE_3, "LED morse element: %s", to_string( element_curr_ ) );
    
    switch ( element_curr_ )
    {
        case meDit:
            sample_source_ = dit_;
            break;
        case meDah:
            sample_source_ = dah_;
            break;
        case meInterElement:
            sample_source_ = interelement_;
            break;
        case meInterCharacter:
            sample_source_ = interletter_;
            break;
        case meInterWord:
            sample_source_ = interword_;
            break;
        case meNone:
        case meEndOfMessage:
        case meInvalid:
            sample_source_ = dummy_;
            break;
    }

    log_writeln_fmt( C_log::LL_VERBOSE_3, "Element: %s", to_string( element_curr_ ) );

    sample_source_->trigger();
}

}
