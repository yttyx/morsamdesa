/*
    Copyright (C) 2018  yttyx. This file is part of morsamdesa.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
*/

// audio_morse.cpp

#include <assert.h>

#include <stdio.h>
#include <stdlib.h>

#include "audio_morse.h"
#include "config.h"
#include "log.h"

using namespace  morsamdesa;

namespace morsamdesa
{

extern C_config  cfg;
extern C_log     log;


C_audio_morse::C_audio_morse( const S_transmitter & transmitter )
    : transmitter_( transmitter )
{
    sending_ = false;
    interrupt_ = false;
    element_curr_ = meNone;
}

C_audio_morse::~C_audio_morse()
{
}

bool
C_audio_morse::initialise()
{
    morse_timing_.reset( new C_morse_timing( transmitter_.speed_char
                                           , transmitter_.speed_effective
                                           , transmitter_.interval_multiplier_char
                                           , transmitter_.interval_multiplier_word
                                           , transmitter_.morse_mode
                                           , transmitter_.morse_code ) );

    text_to_morse_.reset( new C_text_to_morse( transmitter_.alphanumeric_only
                                             , transmitter_.morse_code ) );
    return true;
}

/* /brief Add some sound samples to an output buffer
 *
 * /detail Supply of samples is based around supplying bursts of tick_samples samples or fewer
 *
 */
void
C_audio_morse::write()
{
    if ( sending_ )
    {
        eMorseElement element = meNone;
        
        if ( sample_source_ == dummy_ )
        {
            // Locate the first element that will cause a 'Morse on' event. Since a message can be
            // started at any position in the element stream following a mute/unmute and the resultant
            // switch from LED to audio, this prevents the audio stream from starting with a silent
            // element, which when sounder output is configured gives a spurious armature-up sound.
            
            while ( true )
            {
                element = text_to_morse_->get_element();
                
                if ( ( element == meEndOfMessage ) || ( element == meDit ) || ( element == meDah ) || ( element == meDah2 )|| ( element == meDah3 ) )
                {
                    select_element_sound( element );
                    break;
                }
            }

        }

        // Move through the elements generated by the text to Morse conversion,
        // changing the sample mnemonic with each change of element, always generating
        // tick_samples' worth of data on each call.

        bool samples_exhausted = false;

        while ( element != meEndOfMessage )
        {
            if ( interrupt_ )
            {
                break;
            }

            // write() will return either when the output buffer is full, or when the supply of input samples has been used up

            sample_source_->write( samples_exhausted );

            if ( ! samples_exhausted )
            {
                // There are still element samples to be consumed but the output buffer is full, so we're done
                break;
            }
                
            // Output buffer is not yet full, but this element's samples have all been used up, move on to the next element
            element = text_to_morse_->get_element();

            if ( element != meEndOfMessage )
            {
                select_element_sound( element );
            }
        }

        if ( interrupt_ || ( element == meEndOfMessage ) )
        {
            reset();
        }
    }
}

void
C_audio_morse::reset()
{
    interrupt_     = false;
    sending_       = false;
    sample_source_ = dummy_;
    element_curr_  = meNone;

    reset( dot_ );
    reset( dot_interelement_ );
    reset( dot_interelement_2_ );
    reset( dot_interletter_ );
    reset( dot_interword_ );

    reset( dash_ );
    reset( dash_2_ );
    reset( dash_3_ );
    reset( dash_interelement_ );
    reset( dash_interletter_ );
    reset( dash_interword_ );

    reset( interelement_ );
    reset( interelement_2_ );
    reset( interletter_ );
    reset( interword_ );
}

void
C_audio_morse::reset( shared_ptr< C_sample_source > & sound )
{
    if ( sound.get() )
    {
        sound->reset();
    }
}

void
C_audio_morse::select_element_sound( eMorseElement element )
{
    log_writeln_fmt( C_log::LL_VERBOSE_1, "element: %s", to_string( element ) );
    
    element_curr_ = element;

    switch ( element_curr_ )
    {
        case meDit:
            sample_source_ = dot_;
            break;
        case meDah:
            sample_source_ = dash_;
            break;
        case meDah2:
            sample_source_ = dash_2_;
            break;
        case meDah3:
            sample_source_ = dash_3_;
            break;
        case meInterElement:
            sample_source_ = interelement_;
            break;
        case meInterElement2:
            sample_source_ = interelement_2_;
            break;
        case meInterCharacter:
            sample_source_ = interletter_;
            break;
        case meInterWord:
            sample_source_ = interword_;
            break;
        case meNone:
        case meEndOfMessage:
        case meInvalid:
            sample_source_ = dummy_;
            break;
    }

    if ( sample_source_ )
    {
        sample_source_->trigger();
    }
}

}
